## Fotorresisitor ##

//Código para el arduino:

void setup(){
  pinMode(A0,INPUT);                 
  pinMode(4,OUTPUT);               
  Serial.begin(9600);               
} 
 
void loop(){
  int valorLDR = analogRead(A0);                
     
    if( valorLDR <= 400 ) 
    {
      digitalWrite(4, HIGH);
      Serial.print("LED ON ");
      Serial.println(valorLDR);
      delay(500);
    }
  
    else
    {
      digitalWrite(4, LOW);
      Serial.println("LED OFF");
      Serial.println(valorLDR);
      delay(500);
    }
  }
  
  
  //Código para Visual Studio:
  
  void monitorizar_sensor_luz(Serial* Arduino)
{
float frecuencia, intensidad;
char tecla;
do
 {
 printf("Establezca frecuencia de muestreo (0,5 Hz - 2,0 Hz):");
 scanf_s("%f", &frecuencia);
 } while (frecuencia < 0.5 || frecuencia>2.0);
 printf("Pulse una tecla para finalizar la monitorización\n");
do
 {
 if (Arduino->IsConnected())
 {
 intensiadad = leer_sensor_luz(Arduino);
 if (luz <= 400)
 printf("%.2f ", intensidad);
 else
 printf("XXX ");
 }
 else
 printf("\nNo se ha podido conectar con Arduino.\n");
 if ((1 / frecuencia) * 1000 > PAUSA_MS)
 Sleep((1 / frecuencia) * 1000 - PAUSA_MS);
 }
 while (_kbhit() == 0);
 tecla = _getch();
return;
} 

## Sensor de ultrasonidos ##

//Código para el arduino:
enum Estados {MODO_MANUAL, MODO_ALARMA_ON,MODO_ALARMA_OFF};
Estados estado=MODO_MANUAL;
const int LedPin = 4;
const int EchoPin = 5;
const int TriggerPin = 6;
String mensaje_entrada;
String mensaje_salida;

void setup() {
   Serial.begin(9600);
   pinMode(TriggerPin, OUTPUT);
   pinMode(EchoPin, INPUT);
   pinMode(LedPin, OUTPUT);
}

void loop ()
{
  procesar_mensajes();
  switch (estado)
  {
    case MODO_MANUAL:
        break;
    case MODO_ALARMA_ON:
        modo_alarma(5.0,15.0,2000,3000,1);
        break;
    case MODO_ALARMA_OFF:
        modo_alarma(5.0,15.0,2000,3000,0);
        estado=MODO_MANUAL;
        break;
  }
}

void procesar_mensajes(void)
{
  if( Serial.available()> 0) 
  {
    mensaje_entrada = Serial.readStringUntil('\n');
    if (mensaje_entrada.compareTo("GET_DISTANCIA")==0)
    {
      float cm = ping(TriggerPin, EchoPin);
      mensaje_salida=String("DISTANCIA="+String(cm,3));
    }
    else
      if (mensaje_entrada.compareTo("SET_MODO_ALARMA")==0)
      {
        if (estado==MODO_ALARMA_OFF || estado==MODO_MANUAL)
        {
            estado=MODO_ALARMA_ON;
            mensaje_salida=String("ALARMA_OPERATIVA");
        }
        else
        {
          estado=MODO_ALARMA_OFF;
          mensaje_salida=String("ALARMA_INACTIVA");
         }
      }
      else
        mensaje_salida="COMANDO DESCONOCIDO";

    Serial.println(mensaje_salida);
  }
}

float ping(int TriggerPin, int EchoPin)
 {
   long duration, distanceCm;
   
   digitalWrite(TriggerPin, LOW);  //para generar un pulso limpio ponemos a LOW 4us
   delayMicroseconds(4);
   digitalWrite(TriggerPin, HIGH);  //generamos Trigger (disparo) de 10us
   delayMicroseconds(10);
   digitalWrite(TriggerPin, LOW);
   
   duration = pulseIn(EchoPin, HIGH);  //medimos el tiempo entre pulsos, en microsegundos
   
   distanceCm = duration * 10 / 292/ 2;   //convertimos a distancia, en cm
   return distanceCm;
}


void modo_alarma(float dist_minima, float distancia_maxima,int ms_obstaculo,int ms_led,int modo)
{
  static int  estado_alarma=0; // Estado actual
  static unsigned long  tiempo_alarma=0; // Ref. de tiempo alarma
  static unsigned long tiempo_led_on=0; // Ref. de tiempo led on
  float cm=0.0; // Distancia captada
  int i,rango; 

  if (modo==0)
  {
    estado_alarma=0;
    digitalWrite(LedPin,LOW);
  }
  else
  {
    for (i=0;i<5;i++)  // La medida captada será la media aritmética de cinco sondeos.
      cm += ping(TriggerPin, EchoPin);
    cm=cm/5;
    rango = (cm>=dist_minima && cm<=distancia_maxima) ? 1:0;  // ¿Hay obstáculo en el rango?
    switch (estado_alarma)
     {
       case 0: // Estado inicial
         if (rango==1) // Si detecta un obstáculo
         {
           tiempo_alarma=millis(); // Referencia temporal
           estado_alarma=1; // Cambia al estado 1
         }
         break;
       case 1: // Se acaba de detectar recientemente un obstáculo
         if (millis()-tiempo_alarma>ms_obstaculo) // Si el obstáculo ha permanecido el tiempo mínimo requerido
         {
           estado_alarma=2; // Cambio de estado
           digitalWrite(LedPin,HIGH); // Activa el led de alarma
           Serial.println("ATENCION: SE ACABA DE DETECTAR UN OBSTACULO");
         }
         else
         if (rango==0)  // El obstáculo no ha permanecido el tiempo mínimo
           estado_alarma=0;  // 
        break;
       case 2: // Alarma activa
         if (rango==0)  // Si el obstáculo desaparece del rango
         {
           tiempo_led_on=millis(); // Inicia temporización para mantener el led 
           estado_alarma=3; // Cambio de estado
         }
         break;
       case 3: // No hay obstáculo pero el led continua encendio
         if (millis()-tiempo_led_on>ms_led) // Si ha pasado el tiempo del led on
         {
           digitalWrite(LedPin,LOW); //Apaga led
           estado_alarma=0; //Regresa a estado inicial
           Serial.println("ATENCION:EL OBSTACULO DETECTADO YA NO ESTA PRESENTE");           
         }
         else
          if (rango==1) // Si vuelve a detectar obstáculo
            estado_alarma=2; // Regresa a estado 2
     }
  }
}
 
 //Código para Visual Studio:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <conio.h>
#include "SerialClass/SerialClass.h"

#define MAX_BUFFER 200
#define PAUSA_MS 200

// Funciones prototipo
int menu(void);
void verifica_sensores(Serial*,char*);
void monitorizar_sensor_distancia(Serial*);
void activar_alarma_distancia(Serial* Arduino);
void comprobar_mensajes(Serial*);
float leer_sensor_distancia(Serial*);
int Enviar_y_Recibir(Serial* ,const char* , char* ); 
float float_from_cadena(char* cadena);

int main(void)
{
	Serial* Arduino;
	char puerto[] = "COM3"; // Puerto serie al que está conectado Arduino
	int opcion_menu;

	setlocale(LC_ALL, "es-ES");
	Arduino = new Serial((char*)puerto);
	do
	{
		comprobar_mensajes(Arduino);
		opcion_menu = menu();
		switch (opcion_menu)
		{
		case 0: break;
		case 1: 
			verifica_sensores(Arduino,puerto);
			break;
		case 2:
			monitorizar_sensor_distancia(Arduino);
			break;
		case 3:
			activar_alarma_distancia(Arduino);
			break;
		case 4:
			break;
		default: printf("\nOpción incorrecta\n");
		}
	} while (opcion_menu != 4);
	return 0;
}

// *********************************************************************************
// La función menú se limita a mostrar en pantalla la oferta de opciones disponibles
// *********************************************************************************
int menu(void)
{
	static int opcion=-1;
	
	if (opcion != 0)
	{
		printf("\n");
		printf("Menú Principal\n");
		printf("==============\n");
		printf("1 - Verificar sensores.\n");
		printf("2 - Monitorizar sensores.\n");
		printf("3 - Activar/Desactivar alarma por distancia\n");
		printf("4 - Salir de la aplicación\n");
		printf("Opción:");
	}
	if (_kbhit())
	{
		opcion = (int)_getch()-'0';
		printf("%d\n", opcion);
	}
	else
		opcion = 0;
	return opcion;
}

void comprobar_mensajes(Serial* Arduino)
{
	int bytesRecibidos, total = 0;
	char mensaje_recibido[MAX_BUFFER];

	bytesRecibidos = Arduino->ReadData(mensaje_recibido, sizeof(char) * MAX_BUFFER - 1);
	while (bytesRecibidos > 0)
	{
		Sleep(PAUSA_MS);
		total += bytesRecibidos;
		bytesRecibidos = Arduino->ReadData(mensaje_recibido + total, sizeof(char) * MAX_BUFFER - 1);
	}
	if (total > 0)
	{
		mensaje_recibido[total-1] = '\0';
		printf("\nMensaje recibido: %s\n", mensaje_recibido);
	}
}

void activar_alarma_distancia(Serial* Arduino)
{
	int bytesRecibidos;
	char mensaje_recibido[MAX_BUFFER];

	bytesRecibidos = Enviar_y_Recibir(Arduino, "SET_MODO_ALARMA\n", mensaje_recibido);
	if (bytesRecibidos <= 0)
		printf("\nNo se ha recibido confirmación\n");
	else
		printf("\n%s\n", mensaje_recibido);
}

void monitorizar_sensor_distancia(Serial* Arduino)
{
	float frecuencia, distancia;
	char tecla;
	do
	{
		printf("Establezca frecuencia de muestreo (0,5 Hz - 2,0 Hz):");
		scanf_s("%f", &frecuencia);
	} while (frecuencia < 0.5 || frecuencia>2.0);

	printf("Pulse una tecla para finalizar la monitorización\n");
	do
	{
		if (Arduino->IsConnected())
		{
			distancia = leer_sensor_distancia(Arduino);
			if (distancia != -1)
				printf("%.2f ", distancia);
			else
				printf("XXX ");
		}
		else
			printf("\nNo se ha podido conectar con Arduino.\n");
		if ((1 / frecuencia) * 1000 > PAUSA_MS)
		  Sleep((1 / frecuencia) * 1000 - PAUSA_MS);
	} while (_kbhit() == 0);
	tecla = _getch();
	return;
}

void verifica_sensores(Serial* Arduino,char* port)
{
	float distancia;

	if (Arduino->IsConnected())
	{
		distancia = leer_sensor_distancia(Arduino);
		if (distancia!=-1)
		  printf("\nDistancia: %f\n", distancia);
	}
	else
	{
		printf("\nNo se ha podido conectar con Arduino.\n");
		printf("Revise la conexión, el puerto %s y desactive el monitor serie del IDE de Arduino.\n",port);
	}
}

float leer_sensor_distancia(Serial* Arduino)
{
	float distancia;
	int bytesRecibidos;
	char mensaje_recibido[MAX_BUFFER];
	
	bytesRecibidos = Enviar_y_Recibir(Arduino, "GET_DISTANCIA\n", mensaje_recibido);

	if (bytesRecibidos <= 0)
		distancia = -1;
	else
		distancia = float_from_cadena(mensaje_recibido);
	return distancia;
}

int Enviar_y_Recibir(Serial* Arduino, const char* mensaje_enviar, char* mensaje_recibir)
{
	int bytes_recibidos=0,total=0;
	int intentos = 0,fin_linea=0;


	Arduino->WriteData((char *)mensaje_enviar,strlen(mensaje_enviar));
	Sleep(PAUSA_MS);

	bytes_recibidos = Arduino->ReadData(mensaje_recibir,sizeof(char)*MAX_BUFFER-1);

	while ((bytes_recibidos > 0 || intentos < 5) && fin_linea==0)
	{
		if (bytes_recibidos > 0)
		{
			total += bytes_recibidos;
			if (mensaje_recibir[total - 1] == 13 || mensaje_recibir[total - 1] == 10)
				fin_linea = 1;
		}
		else
			intentos++;
		Sleep(PAUSA_MS);
		bytes_recibidos = Arduino->ReadData(mensaje_recibir+total, sizeof(char) * MAX_BUFFER - 1);
	}
	if (total > 0)
		mensaje_recibir[total - 1] = '\0';

	//printf("LOG: %d bytes -> %s\nIntentos=%d - EOLN=%d\n", total, mensaje_recibir,intentos,fin_linea);
	return total;
}





float float_from_cadena(char* cadena)
{
	float numero = 0;
	int i, divisor = 10, estado = 0;


	for (i=0;cadena[i]!='\0' && estado!=3 && i<MAX_BUFFER;i++)
		switch (estado)
		{
		case 0:// Antes del número
			if (cadena[i] >= '0' && cadena[i] <= '9')
			{
				numero = cadena[i] - '0';
				estado = 1;
			}
			break;
		case 1:// Durante el número
			if (cadena[i] >= '0' && cadena[i] <= '9')
				numero = numero * 10 + cadena[i] - '0';
			else
				if (cadena[i] == '.' || cadena[i] == ',')
					estado = 2;
				else
					estado = 3;
			break;
		case 2: // Parte decimal
			if (cadena[i] >= '0' && cadena[i] <= '9')
			{
				numero = numero + (float)(cadena[i] - '0') / divisor;
				divisor *= 10;
			}
			else
				estado = 3;
			break;
		}
	return numero;
} 
